📖 번역
Chapter VII

soli[D] - 의존 역전 원칙 (Dependency Inversion)

Exercise 04

과제 04: soli[D] - 의존 역전 원칙

제출 디렉토리 : ex04/

제출해야 할 파일 : ILogger.hpp, *.hpp, main.cpp

허용 함수 : 없음

이 과제에서는 로그 파일/출력 시스템을 만들어야 합니다.

ILogger 클래스를 만들고, 최소한 아래의 메서드를 포함해야 합니다:

virtual void write(std::string) = 0;


그리고 다음 조건을 만족하는 파생 클래스를 작성해야 합니다:

문자열을 파일에 기록하는 Logger

문자열을 std::ostream(예: std::cout)에 기록하는 Logger

두 종류의 Logger는 문자열 앞에 **헤더(header)**를 붙일 수도 있습니다. 헤더는 다음 중 하나일 수 있습니다:

고정된 문자열(constant string)

메시지가 출력되는 날짜(date)

⚠️ 헤더는 옵션 사항입니다.
따라서 헤더가 필요 없는 Logger 클래스에 강제로 헤더 기능을 넣어서는 안 됩니다.

테스트 조건

std::vector<ILogger*> 안에 여러분이 만든 모든 Logger 객체를 넣습니다.

동시에 여러 개의 문자열 목록을 준비합니다.

main.cpp에서 문자열 목록을 순회하면서, 모든 Logger가 각각의 문자열을 출력하도록 하여 Logger들이 올바르게 동작하는지 확인해야 합니다.

제약 조건

ILogger 안에는 아무것도 추가할 수 없습니다. → 순수 인터페이스로 남겨야 합니다.

Interface Segregation Principle(인터페이스 분리 원칙)에서 배운 내용을 떠올리세요:

"고정 문자열 헤더"가 "날짜 헤더"를 알 필요가 있나요? ❌

"헤더가 없는 Logger"가 "헤더 출력 방식"을 알 필요가 있나요? ❌

👉 마지막으로 main.cpp에서 코드가 잘 동작하는 예시를 보여줘야 하며,
👉 반드시 **의존 역전 원칙(DIP)**을 지켜야 합니다.

📘 의존 역전 원칙(DIP, Dependency Inversion Principle) 설명

의존 역전 원칙은 SOLID 원칙의 마지막 규칙으로, 핵심 아이디어는 다음과 같습니다:

"고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화(인터페이스)에 의존해야 한다."

🔎 쉽게 풀어서 말하면:

고수준 모듈 = 핵심 로직 (예: 로그 시스템)

저수준 모듈 = 구체적 구현 (예: 파일 Logger, 콘솔 Logger, DB Logger)

보통은 고수준 모듈이 저수준 모듈을 직접 사용하면, 새로운 요구사항(예: "이제 로그를 네트워크 서버에도 보내라")이 생길 때마다 고수준 모듈을 수정해야 합니다. → OCP 위반

➡️ DIP를 적용하면, 고수준 모듈은 구체적 구현이 아니라 **인터페이스(추상화)**에만 의존합니다.
즉, ILogger라는 인터페이스에만 의존하고, 실제 구현체(파일, 콘솔, 네트워크)는 나중에 갈아 끼울 수 있습니다.

📌 DIP 장점

확장성 : 새로운 Logger(예: DBLogger, RemoteLogger)를 추가해도 기존 시스템 수정 필요 없음.

유연성 : 런타임에 어떤 구현을 쓸지 바꿀 수 있음.

테스트 용이성 : 단위 테스트할 때 가짜(MockLogger)를 만들어 쉽게 검증 가능.

👉 정리: 이 과제에서 DIP는

ILogger 인터페이스(추상화)에 의존 → ✅

FileLogger, OstreamLogger는 이 인터페이스 구현체 → ✅

main.cpp는 ILogger*만 보고 동작 → ✅